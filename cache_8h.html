<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libOGC: gc/ogc/cache.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libOGC
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_3f99a9bc569bbfd19484ce6f0200cc9f.html">gc</a></li><li class="navelem"><a class="el" href="dir_0d653af529ccb60d59d9e4c4f945aef6.html">ogc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cache.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Cache subsystem.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="gctypes_8h.html">gctypes.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a579f66a19eae5e54965934949e9b4513"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a579f66a19eae5e54965934949e9b4513"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LC_BASE</b>&#160;&#160;&#160;(LC_BASEPREFIX&lt;&lt;16)</td></tr>
<tr class="separator:a579f66a19eae5e54965934949e9b4513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3844aeb3a1f20c35b855fb4cc13b43a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3844aeb3a1f20c35b855fb4cc13b43a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LC_BASEPREFIX</b>&#160;&#160;&#160;0xe000</td></tr>
<tr class="separator:a3844aeb3a1f20c35b855fb4cc13b43a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec90e2a72068a1345a80b970bb676d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ec90e2a72068a1345a80b970bb676d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LCGetBase</b>()&#160;&#160;&#160;((void*)LC_BASE)</td></tr>
<tr class="separator:a2ec90e2a72068a1345a80b970bb676d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a157e9185e621c7900132d0f280127e47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a157e9185e621c7900132d0f280127e47">DCDisable</a> (void)</td></tr>
<tr class="memdesc:a157e9185e621c7900132d0f280127e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable L1 d-cache.  <a href="#a157e9185e621c7900132d0f280127e47">More...</a><br /></td></tr>
<tr class="separator:a157e9185e621c7900132d0f280127e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d360a6c92b4c417e8dc6e2887a31e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#ae0d360a6c92b4c417e8dc6e2887a31e8">DCEnable</a> (void)</td></tr>
<tr class="memdesc:ae0d360a6c92b4c417e8dc6e2887a31e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable L1 d-cache.  <a href="#ae0d360a6c92b4c417e8dc6e2887a31e8">More...</a><br /></td></tr>
<tr class="separator:ae0d360a6c92b4c417e8dc6e2887a31e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2ba9e4053761c48638b7766e7cf451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a2c2ba9e4053761c48638b7766e7cf451">DCFlashInvalidate</a> (void)</td></tr>
<tr class="memdesc:a2c2ba9e4053761c48638b7766e7cf451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate L1 d-cache.  <a href="#a2c2ba9e4053761c48638b7766e7cf451">More...</a><br /></td></tr>
<tr class="separator:a2c2ba9e4053761c48638b7766e7cf451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc716be779d6e117a9fe4526e9c38270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#abc716be779d6e117a9fe4526e9c38270">DCFlushRange</a> (void *startaddress, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a> len)</td></tr>
<tr class="memdesc:abc716be779d6e117a9fe4526e9c38270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes a given range.  <a href="#abc716be779d6e117a9fe4526e9c38270">More...</a><br /></td></tr>
<tr class="separator:abc716be779d6e117a9fe4526e9c38270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec64ece0e02008f1b78a54b7b89dac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a9ec64ece0e02008f1b78a54b7b89dac6">DCFlushRangeNoSync</a> (void *startaddress, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a> len)</td></tr>
<tr class="memdesc:a9ec64ece0e02008f1b78a54b7b89dac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes a given range.  <a href="#a9ec64ece0e02008f1b78a54b7b89dac6">More...</a><br /></td></tr>
<tr class="separator:a9ec64ece0e02008f1b78a54b7b89dac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d22f96b5b2742f80e0acf973602399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a59d22f96b5b2742f80e0acf973602399">DCFreeze</a> (void)</td></tr>
<tr class="memdesc:a59d22f96b5b2742f80e0acf973602399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current contents of the L1 d-cache are locked down and will not be cast out.  <a href="#a59d22f96b5b2742f80e0acf973602399">More...</a><br /></td></tr>
<tr class="separator:a59d22f96b5b2742f80e0acf973602399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fabc9444d5ec85db2c780fea0288a1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a5fabc9444d5ec85db2c780fea0288a1c">DCInvalidateRange</a> (void *startaddress, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a> len)</td></tr>
<tr class="memdesc:a5fabc9444d5ec85db2c780fea0288a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates a given range of the d-cache.  <a href="#a5fabc9444d5ec85db2c780fea0288a1c">More...</a><br /></td></tr>
<tr class="separator:a5fabc9444d5ec85db2c780fea0288a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5997dc8fcc6e6890126e09f6043b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a7e5997dc8fcc6e6890126e09f6043b58">DCStoreRange</a> (void *startaddress, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a> len)</td></tr>
<tr class="memdesc:a7e5997dc8fcc6e6890126e09f6043b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures a range of memory is updated with any modified data in the cache.  <a href="#a7e5997dc8fcc6e6890126e09f6043b58">More...</a><br /></td></tr>
<tr class="separator:a7e5997dc8fcc6e6890126e09f6043b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44470e191ecb9c51d4a0f31c44a7871b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a44470e191ecb9c51d4a0f31c44a7871b">DCStoreRangeNoSync</a> (void *startaddress, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a> len)</td></tr>
<tr class="memdesc:a44470e191ecb9c51d4a0f31c44a7871b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures a range of memory is updated with any modified data in the cache.  <a href="#a44470e191ecb9c51d4a0f31c44a7871b">More...</a><br /></td></tr>
<tr class="separator:a44470e191ecb9c51d4a0f31c44a7871b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc0409eff5aa756d1cdcefeece16d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a7fc0409eff5aa756d1cdcefeece16d86">DCTouchRange</a> (void *startaddress, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a> len)</td></tr>
<tr class="memdesc:a7fc0409eff5aa756d1cdcefeece16d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a range of memory into cache.  <a href="#a7fc0409eff5aa756d1cdcefeece16d86">More...</a><br /></td></tr>
<tr class="separator:a7fc0409eff5aa756d1cdcefeece16d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eafe04d3af653c62ba6c68bad816cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a8eafe04d3af653c62ba6c68bad816cf9">DCUnfreeze</a> (void)</td></tr>
<tr class="memdesc:a8eafe04d3af653c62ba6c68bad816cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undoes actions of <a class="el" href="cache_8h.html#a59d22f96b5b2742f80e0acf973602399" title="Current contents of the L1 d-cache are locked down and will not be cast out. ">DCFreeze()</a>.  <a href="#a8eafe04d3af653c62ba6c68bad816cf9">More...</a><br /></td></tr>
<tr class="separator:a8eafe04d3af653c62ba6c68bad816cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f055136f3b52e431efb948bc01454d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a6f055136f3b52e431efb948bc01454d3">DCZeroRange</a> (void *startaddress, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a> len)</td></tr>
<tr class="memdesc:a6f055136f3b52e431efb948bc01454d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a range of memory into cache and zeroes all the cache lines.  <a href="#a6f055136f3b52e431efb948bc01454d3">More...</a><br /></td></tr>
<tr class="separator:a6f055136f3b52e431efb948bc01454d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f0395b2499f3fdaa3e420b0d825071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#ae7f0395b2499f3fdaa3e420b0d825071">ICBlockInvalidate</a> (void *startaddress)</td></tr>
<tr class="memdesc:ae7f0395b2499f3fdaa3e420b0d825071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates a block in the i-cache.  <a href="#ae7f0395b2499f3fdaa3e420b0d825071">More...</a><br /></td></tr>
<tr class="separator:ae7f0395b2499f3fdaa3e420b0d825071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76da4d344cd77a7fae391964f7658735"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a76da4d344cd77a7fae391964f7658735">ICDisable</a> (void)</td></tr>
<tr class="memdesc:a76da4d344cd77a7fae391964f7658735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable L1 i-cache.  <a href="#a76da4d344cd77a7fae391964f7658735">More...</a><br /></td></tr>
<tr class="separator:a76da4d344cd77a7fae391964f7658735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7e42eba2c8d5be1b1e684d048b2ea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a5c7e42eba2c8d5be1b1e684d048b2ea1">ICEnable</a> (void)</td></tr>
<tr class="memdesc:a5c7e42eba2c8d5be1b1e684d048b2ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable L1 i-cache.  <a href="#a5c7e42eba2c8d5be1b1e684d048b2ea1">More...</a><br /></td></tr>
<tr class="separator:a5c7e42eba2c8d5be1b1e684d048b2ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdc4b48f079e44019ed3d91c5c63339"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#abfdc4b48f079e44019ed3d91c5c63339">ICFlashInvalidate</a> (void)</td></tr>
<tr class="memdesc:abfdc4b48f079e44019ed3d91c5c63339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate the L1 i-cache.  <a href="#abfdc4b48f079e44019ed3d91c5c63339">More...</a><br /></td></tr>
<tr class="separator:abfdc4b48f079e44019ed3d91c5c63339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8953bc422a301e2a6f70723957f172e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a8953bc422a301e2a6f70723957f172e1">ICFreeze</a> (void)</td></tr>
<tr class="memdesc:a8953bc422a301e2a6f70723957f172e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current contents of the L1 i-cache are locked down and will not be cast out.  <a href="#a8953bc422a301e2a6f70723957f172e1">More...</a><br /></td></tr>
<tr class="separator:a8953bc422a301e2a6f70723957f172e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bb8d456777bafa6ecbe15b7cb0ed2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#af3bb8d456777bafa6ecbe15b7cb0ed2a">ICInvalidateRange</a> (void *startaddress, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a> len)</td></tr>
<tr class="memdesc:af3bb8d456777bafa6ecbe15b7cb0ed2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate a range in the L1 i-cache.  <a href="#af3bb8d456777bafa6ecbe15b7cb0ed2a">More...</a><br /></td></tr>
<tr class="separator:af3bb8d456777bafa6ecbe15b7cb0ed2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d6e31dc939812889805bea7692d622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a75d6e31dc939812889805bea7692d622">ICSync</a> (void)</td></tr>
<tr class="memdesc:a75d6e31dc939812889805bea7692d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an instruction cache synchronization.  <a href="#a75d6e31dc939812889805bea7692d622">More...</a><br /></td></tr>
<tr class="separator:a75d6e31dc939812889805bea7692d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935108bdb96f9dda33345870a91e0943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache_8h.html#a935108bdb96f9dda33345870a91e0943">ICUnfreeze</a> (void)</td></tr>
<tr class="memdesc:a935108bdb96f9dda33345870a91e0943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undoes actions of <a class="el" href="cache_8h.html#a8953bc422a301e2a6f70723957f172e1" title="Current contents of the L1 i-cache are locked down and will not be cast out. ">ICFreeze()</a>.  <a href="#a935108bdb96f9dda33345870a91e0943">More...</a><br /></td></tr>
<tr class="separator:a935108bdb96f9dda33345870a91e0943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421706340758ed85209e0c9839c25ffb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a421706340758ed85209e0c9839c25ffb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LCAlloc</b> (void *, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>)</td></tr>
<tr class="separator:a421706340758ed85209e0c9839c25ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec10cf1ecc6ebeaf9f37d3b83504e06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeec10cf1ecc6ebeaf9f37d3b83504e06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LCAllocNoInvalidate</b> (void *, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>)</td></tr>
<tr class="separator:aeec10cf1ecc6ebeaf9f37d3b83504e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ff6d4d274c9b9e951f59f64ca74e95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45ff6d4d274c9b9e951f59f64ca74e95"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LCAllocOneTag</b> (BOOL, void *)</td></tr>
<tr class="separator:a45ff6d4d274c9b9e951f59f64ca74e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b12361afe2c2addb527449c9567b764"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b12361afe2c2addb527449c9567b764"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LCAllocTags</b> (BOOL, void *, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>)</td></tr>
<tr class="separator:a2b12361afe2c2addb527449c9567b764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175d62ba1caad8b54b649b4ff312defe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a175d62ba1caad8b54b649b4ff312defe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LCDisable</b> (void)</td></tr>
<tr class="separator:a175d62ba1caad8b54b649b4ff312defe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c03c90f329fa166f157478931372af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0c03c90f329fa166f157478931372af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LCEnable</b> (void)</td></tr>
<tr class="separator:ae0c03c90f329fa166f157478931372af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04035e82c6a8a692d57e8ecdb8b46020"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04035e82c6a8a692d57e8ecdb8b46020"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LCFlushQueue</b> (void)</td></tr>
<tr class="separator:a04035e82c6a8a692d57e8ecdb8b46020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1be0f41f47658e623076539c15cbb88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1be0f41f47658e623076539c15cbb88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LCLoadBlocks</b> (void *, void *, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>)</td></tr>
<tr class="separator:ab1be0f41f47658e623076539c15cbb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d52fa8a60802a8b3d2443eaf4d9efb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d52fa8a60802a8b3d2443eaf4d9efb6"></a>
<a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LCLoadData</b> (void *, void *, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>)</td></tr>
<tr class="separator:a2d52fa8a60802a8b3d2443eaf4d9efb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4200298c2ba56a7b9f61f274414c0ee9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4200298c2ba56a7b9f61f274414c0ee9"></a>
<a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LCQueueLength</b> (void)</td></tr>
<tr class="separator:a4200298c2ba56a7b9f61f274414c0ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57595fb03f08141440d313ad883af141"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57595fb03f08141440d313ad883af141"></a>
<a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LCQueueWait</b> (<a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>)</td></tr>
<tr class="separator:a57595fb03f08141440d313ad883af141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d5b6719f6043d6d9df1186b97c3b9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1d5b6719f6043d6d9df1186b97c3b9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LCStoreBlocks</b> (void *, void *, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>)</td></tr>
<tr class="separator:ad1d5b6719f6043d6d9df1186b97c3b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a41b31555f2f8d0ac80965ba407855f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a41b31555f2f8d0ac80965ba407855f"></a>
<a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LCStoreData</b> (void *, void *, <a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>)</td></tr>
<tr class="separator:a6a41b31555f2f8d0ac80965ba407855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Cache subsystem. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a157e9185e621c7900132d0f280127e47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable L1 d-cache. </p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="ae0d360a6c92b4c417e8dc6e2887a31e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable L1 d-cache. </p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a2c2ba9e4053761c48638b7766e7cf451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCFlashInvalidate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate L1 d-cache. </p>
<p>An invalidate operation is issued that marks the state of each data cache block as invalid without writing back modified cache blocks to memory.<br />
 Cache access is blocked during this time.Bus accesses to the cache are signaled as a miss during invalidate-all operations.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="abc716be779d6e117a9fe4526e9c38270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCFlushRange </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startaddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes a given range. </p>
<p>If any part of the range hits in the d-cache the corresponding block will be flushed to main memory and invalidated.<br />
 <b><em>NOTE:</em></b> This function invokes a "sync" after flushing the range. This means the function will stall until the CPU knows that the data has been writen to main memory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startaddress</td><td>pointer to the startaddress of the memory range to flush. <b><em>NOTE:</em></b> Has to be aligned on a 32byte boundery </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of range to be flushed. <b><em>NOTE:</em></b> Should be a multiple of 32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a9ec64ece0e02008f1b78a54b7b89dac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCFlushRangeNoSync </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startaddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes a given range. </p>
<p>If any part of the range hits in the d-cache the corresponding block will be flushed to main memory and invalidated.<br />
 <b><em>NOTE:</em></b> This routine does not perform a "sync" to ensure that the range has been flushed to memory. That is, the cache blocks are sent to the bus interface unit for storage to main memory, but by the time this function returns, you are not guaranteed that the blocks have been written to memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startaddress</td><td>pointer to the startaddress of the memory range to flush. <b><em>NOTE:</em></b> Has to be aligned on a 32byte boundery </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of range to be flushed. <b><em>NOTE:</em></b> Should be a multiple of 32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a59d22f96b5b2742f80e0acf973602399"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCFreeze </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current contents of the L1 d-cache are locked down and will not be cast out. </p>
<p>Hits are still serviced, but misses go straight to L2 or 60x bus. Most cache operations, such as <a class="el" href="cache_8h.html#abc716be779d6e117a9fe4526e9c38270" title="Flushes a given range. ">DCFlushRange()</a>, will still execute regardless of whether the cache is frozen.<br />
 <b><em>NOTE:</em></b> In PowerPC architecture jargon, this feature is referred to as "locking" the data cache. We use the word "freeze" to distinguish it from the locked cache and DMA features.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a5fabc9444d5ec85db2c780fea0288a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCInvalidateRange </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startaddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates a given range of the d-cache. </p>
<p>If any part of the range hits in the d-cache, the corresponding block will be invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startaddress</td><td>pointer to the startaddress of the memory range to invalidate. <b><em>NOTE:</em></b> Has to be aligned on a 32byte boundery </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the range to invalidate. <b><em>NOTE:</em></b> Should be a multiple of 32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a7e5997dc8fcc6e6890126e09f6043b58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCStoreRange </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startaddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures a range of memory is updated with any modified data in the cache. </p>
<p><b><em>NOTE:</em></b> This function invokes a "sync" after storing the range. This means the function will stall until the CPU knows that the data has been writen to main memory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startaddress</td><td>pointer to the startaddress of the memory range to store. <b><em>NOTE:</em></b> Has to be aligned on a 32byte boundery </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the range to store. <b><em>NOTE:</em></b> Should be a multiple of 32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a44470e191ecb9c51d4a0f31c44a7871b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCStoreRangeNoSync </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startaddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures a range of memory is updated with any modified data in the cache. </p>
<p><b><em>NOTE:</em></b> This routine does not perform a "sync" to ensure that the range has been flushed to memory. That is, the cache blocks are sent to the bus interface unit for storage to main memory, but by the time this function returns, you are not guaranteed that the blocks have been written to memory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startaddress</td><td>pointer to the startaddress of the memory range to store. <b><em>NOTE:</em></b> Has to be aligned on a 32byte boundery </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the range to store. <b><em>NOTE:</em></b> Should be a multiple of 32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a7fc0409eff5aa756d1cdcefeece16d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCTouchRange </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startaddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a range of memory into cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startaddress</td><td>pointer to the startaddress of the memory range to load. <b><em>NOTE:</em></b> Has to be aligned on a 32byte boundery </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the range to load. <b><em>NOTE:</em></b> Should be a multiple of 32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a8eafe04d3af653c62ba6c68bad816cf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCUnfreeze </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undoes actions of <a class="el" href="cache_8h.html#a59d22f96b5b2742f80e0acf973602399" title="Current contents of the L1 d-cache are locked down and will not be cast out. ">DCFreeze()</a>. </p>
<p>Old cache blocks will now be cast out on subsequent L1 misses.<br />
 <b><em>NOTE:</em></b> In PowerPC architecture jargon, this feature is referred to as "locking" the data cache. We use the word "freeze" to distinguish it from the locked cache and DMA features.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a6f055136f3b52e431efb948bc01454d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCZeroRange </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startaddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a range of memory into cache and zeroes all the cache lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startaddress</td><td>pointer to the startaddress of the memory range to load/zero. <b><em>NOTE:</em></b> Has to be aligned on a 32byte boundery </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the range to load/zero. <b><em>NOTE:</em></b> Should be a multiple of 32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="ae7f0395b2499f3fdaa3e420b0d825071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ICBlockInvalidate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startaddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates a block in the i-cache. </p>
<p>If the block hits in the i-cache, the corresponding block will be invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startaddress</td><td>pointer to the startaddress of the memory block to invalidate. <b><em>NOTE:</em></b> Has to be aligned on a 32byte boundery</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a76da4d344cd77a7fae391964f7658735"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ICDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable L1 i-cache. </p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a5c7e42eba2c8d5be1b1e684d048b2ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ICEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable L1 i-cache. </p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="abfdc4b48f079e44019ed3d91c5c63339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ICFlashInvalidate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate the L1 i-cache. </p>
<p>An invalidate operation is issued that marks the state of each instruction cache block as invalid without writing back modified cache blocks to memory.<br />
 Cache access is blocked during this time. Bus accesses to the cache are signaled as a miss during invalidate-all operations.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a8953bc422a301e2a6f70723957f172e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ICFreeze </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current contents of the L1 i-cache are locked down and will not be cast out. </p>
<p>Hits are still serviced, but misses go straight to L2 or 60x bus.<br />
 <b><em>NOTE:</em></b> In PowerPC architecture jargon, this feature is referred to as "locking" the data cache. We use the word "freeze" to distinguish it from the locked cache and DMA features.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="af3bb8d456777bafa6ecbe15b7cb0ed2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ICInvalidateRange </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startaddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gctypes_8h.html#afaa62991928fb9fb18ff0db62a040aba">u32</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate a range in the L1 i-cache. </p>
<p>If any part of the range hits in the i-cache, the corresponding block will be invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startaddress</td><td>pointer to the startaddress of the memory range to invalidate. <b><em>NOTE:</em></b> Has to be aligned on a 32byte boundery </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the range to invalidate. <b><em>NOTE:</em></b> Should be a multiple of 32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a75d6e31dc939812889805bea7692d622"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ICSync </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an instruction cache synchronization. </p>
<p>This ensures that all instructions preceding this instruction have completed before this instruction completes.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a935108bdb96f9dda33345870a91e0943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ICUnfreeze </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undoes actions of <a class="el" href="cache_8h.html#a8953bc422a301e2a6f70723957f172e1" title="Current contents of the L1 i-cache are locked down and will not be cast out. ">ICFreeze()</a>. </p>
<p>Old cache blocks will now be cast out on subsequent L1 misses.<br />
 <b><em>NOTE:</em></b> In PowerPC architecture jargon, this feature is referred to as "locking" the data cache. We use the word "freeze" to distinguish it from the locked cache and DMA features.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 15 2018 18:53:33 for libOGC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
